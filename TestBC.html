<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimAlgo Learning - Test Backtracking Combinatoric</title>
    <link rel="stylesheet" href="TestBC.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="navbar">
        <div class="navbar-content">
            <div class="logo">
                <img src="logo.png" alt="SimAlgo Learning Logo" class="logo-img">
                SimAlgo Learning
            </div>
            <nav>
                <ul class="nav-links">
                    <li><a href="home.html">HOME</a></li>
                    <li><a href="Algoritmi.html">Algoritmi</a></li>
                    <li><a href="Despre.html">Despre noi</a></li>
                </ul>
            </nav>
            <button class="nav-toggle" aria-label="toggle navigation">
                <span class="hamburger"></span>
            </button>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <h1>Test Backtracking Combinatoric</h1>
            <form id="quiz-form">
                <div class="question">
                    <h3>1. Ce este algoritmul de backtracking combinatoric?</h3>
                    <label><input type="radio" name="q1" value="a"> Algoritm de căutare a unei soluții</label>
                    <label><input type="radio" name="q1" value="b"> Algoritm de sortare a elementelor</label>
                    <label><input type="radio" name="q1" value="c"> Algoritm de optimizare a resurselor</label>
                    <label><input type="radio" name="q1" value="d"> Algoritm de calcul al costurilor</label>
                </div>
                <div class="question">
                    <h3>2. Cum funcționează backtracking-ul combinatoric?</h3>
                    <label><input type="radio" name="q2" value="a"> Prin explorarea tuturor soluțiilor posibile</label>
                    <label><input type="radio" name="q2" value="b"> Prin sortarea elementelor în ordine crescătoare</label>
                    <label><input type="radio" name="q2" value="c"> Prin împărțirea problemei în subprobleme mai mici</label>
                    <label><input type="radio" name="q2" value="d"> Prin utilizarea unei cozi de priorități</label>
                </div>
                <div class="question">
                    <h3>3. Ce problemă clasică se poate rezolva folosind backtracking-ul combinatoric?</h3>
                    <label><input type="radio" name="q3" value="a"> Problema rucsacului</label>
                    <label><input type="radio" name="q3" value="b"> Problema celor 8 regine</label>
                    <label><input type="radio" name="q3" value="c"> Problema drumului minim</label>
                    <label><input type="radio" name="q3" value="d"> Problema sortării</label>
                </div>
                <div class="question">
                    <h3>4. Cum este determinată o soluție validă în algoritmul de backtracking combinatoric?</h3>
                    <label><input type="radio" name="q4" value="a"> Prin verificarea fiecărui nod în ordinea parcurgerii</label>
                    <label><input type="radio" name="q4" value="b"> Prin sortarea tuturor nodurilor</label>
                    <label><input type="radio" name="q4" value="c"> Prin utilizarea unui graf aciclic</label>
                    <label><input type="radio" name="q4" value="d"> Prin explorarea recursivă a tuturor opțiunilor</label>
                </div>
                <div class="question">
                    <h3>5. Ce tehnică de programare utilizează backtracking-ul combinatoric?</h3>
                    <label><input type="radio" name="q5" value="a"> Divide et impera</label>
                    <label><input type="radio" name="q5" value="b"> Programare dinamică</label>
                    <label><input type="radio" name="q5" value="c"> Recursivitate</label>
                    <label><input type="radio" name="q5" value="d"> Greedy</label>
                </div>
                <div class="question">
                    <h3>6. Ce înseamnă backtracking?</h3>
                    <label><input type="radio" name="q6" value="a"> Întoarcerea la ultima decizie validă și încercarea altei opțiuni</label>
                    <label><input type="radio" name="q6" value="b"> Împărțirea problemei în subprobleme</label>
                    <label><input type="radio" name="q6" value="c"> Memorarea soluțiilor subproblemelor</label>
                    <label><input type="radio" name="q6" value="d"> Alegerea celei mai bune opțiuni</label>
                </div>
                <div class="question">
                    <h3>7. Care este avantajul major al backtracking-ului combinatoric?</h3>
                    <label><input type="radio" name="q7" value="a"> Eficiența în timp</label>
                    <label><input type="radio" name="q7" value="b"> Simplitatea implementării</label>
                    <label><input type="radio" name="q7" value="c"> Garanția găsirii soluției optime</label>
                    <label><input type="radio" name="q7" value="d"> Utilizarea memoriei</label>
                </div>
                <div class="question">
                    <h3>8. În ce cazuri backtracking-ul combinatoric poate deveni ineficient?</h3>
                    <label><input type="radio" name="q8" value="a"> Când numărul soluțiilor este foarte mic</label>
                    <label><input type="radio" name="q8" value="b"> Când problema are multe soluții valide</label>
                    <label><input type="radio" name="q8" value="c"> Când problema nu are soluții valide</label>
                    <label><input type="radio" name="q8" value="d"> Când numărul de posibilități este foarte mare</label>
                </div>
                <div class="question">
                    <h3>9. Ce problemă nu poate fi rezolvată eficient prin backtracking combinatoric?</h3>
                    <label><input type="radio" name="q9" value="a"> Problema comis-voiajorului</label>
                    <label><input type="radio" name="q9" value="b"> Sudoku</label>
                    <label><input type="radio" name="q9" value="c"> Sortarea unui șir</label>
                    <label><input type="radio" name="q9" value="d"> Permutarea unui șir</label>
                </div>
                <div class="question">
                    <h3>10. Cum este afectată complexitatea temporală a backtracking-ului combinatoric de numărul de soluții valide?</h3>
                    <label><input type="radio" name="q10" value="a"> Crește exponențial</label>
                    <label><input type="radio" name="q10" value="b"> Scade liniar</label>
                    <label><input type="radio" name="q10" value="c"> Rămâne constantă</label>
                    <label><input type="radio" name="q10" value="d"> Crește logaritmic</label>
                </div>
                <div class="submit-container">
                    <button type="button" class="button" onclick="submitQuiz()">Submit</button>
                </div>
                <div id="result"></div>
                <div id="unanswered-questions" style="color: red;"></div>
            </form>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p class="footer-left">&copy; 2024 SimAlgo Learning</p>
            <p class="footer-center">Made with <span class="heart">❤</span></p>
            <p class="footer-right" id="current-time"></p>
        </div>
    </footer>

    <script>
        const correctAnswers = {
            q1: 'a',
            q2: 'a',
            q3: 'b',
            q4: 'd',
            q5: 'c',
            q6: 'a',
            q7: 'c',
            q8: 'd',
            q9: 'a',
            q10: 'a'
        };

        function submitQuiz() {
            let score = 0;
            let unanswered = 0;
            for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
                const selectedOption = document.querySelector(`input[name="${question}"]:checked`);
                const options = document.querySelectorAll(`input[name="${question}"]`);

                if (!selectedOption) {
                    unanswered++;
                    continue;
                }

                if (selectedOption.value === correctAnswer) {
                    score++;
                    selectedOption.parentElement.classList.add('correct');
                } else {
                    selectedOption.parentElement.classList.add('incorrect');
                    options.forEach(option => {
                        if (option.value === correctAnswer) {
                            option.parentElement.classList.add('correct');
                        }
                    });
                }
            }

            const resultContainer = document.getElementById('result');
            resultContainer.innerHTML = `Scorul tău este: ${score} / 10`;
            const unansweredContainer = document.getElementById('unanswered-questions');
            if (unanswered > 0) {
                unansweredContainer.innerHTML = `Întrebări rămase: ${unanswered}`;
            } else {
                unansweredContainer.innerHTML = '';
            }

            resultContainer.className = '';
            if (score <= 3) {
                resultContainer.classList.add('red');
            } else if (score <= 6) {
                resultContainer.classList.add('orange');
            } else if (score <= 8) {
                resultContainer.classList.add('yellow');
            } else {
                resultContainer.classList.add('green');
            }
        }

        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('current-time').textContent = timeString;
        }
        setInterval(updateTime, 1000);
        updateTime();

        const navToggle = document.querySelector('.nav-toggle');
        const navLinks = document.querySelector('.nav-links');

        navToggle.addEventListener('click', () => {
            navLinks.classList.toggle('nav-links_visible');
        });

        document.querySelectorAll('input[type="radio"]').forEach(input => {
            input.addEventListener('change', () => {
                const name = input.name;
                document.querySelectorAll(`input[name="${name}"]`).forEach(radio => {
                    radio.parentElement.classList.remove('selected');
                });
                input.parentElement.classList.add('selected');
            });
        });
    </script>
</body>
</html>
