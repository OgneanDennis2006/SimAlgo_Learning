<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimAlgo Learning - Test BFS</title>
    <link rel="stylesheet" href="TestBFS.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="navbar">
        <div class="navbar-content">
            <div class="logo">
                <img src="logo.png" alt="SimAlgo Learning Logo" class="logo-img">
                SimAlgo Learning
            </div>
            <nav>
                <ul class="nav-links">
                    <li><a href="home.html">HOME</a></li>
                    <li><a href="Algoritmi.html">Algoritmi</a></li>
                    <li><a href="Despre.html">Despre noi</a></li>
                </ul>
            </nav>
            <button class="nav-toggle" aria-label="toggle navigation">
                <span class="hamburger"></span>
            </button>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <h1>Test BFS</h1>
            <form id="quiz-form">
                <div class="question">
                    <h3>1. Ce tip de căutare utilizează BFS?</h3>
                    <label><input type="radio" name="q1" value="a"> Căutare în adâncime</label>
                    <label><input type="radio" name="q1" value="b"> Căutare în lățime</label>
                    <label><input type="radio" name="q1" value="c"> Căutare binară</label>
                    <label><input type="radio" name="q1" value="d"> Căutare prin interpolare</label>
                </div>
                <div class="question">
                    <h3>2. Ce structură de date este utilizată în BFS pentru a reține nodurile care urmează să fie parcurse?</h3>
                    <label><input type="radio" name="q2" value="a"> Stivă</label>
                    <label><input type="radio" name="q2" value="b"> Coadă</label>
                    <label><input type="radio" name="q2" value="c"> Listă</label>
                    <label><input type="radio" name="q2" value="d"> Arbore binar</label>
                </div>
                <div class="question">
                    <h3>3. Ce reprezintă vectorul „Distanta” în algoritmul BFS?</h3>
                    <label><input type="radio" name="q3" value="a"> Vectorul de noduri vizitate</label>
                    <label><input type="radio" name="q3" value="b"> Vectorul de părinți ai nodurilor</label>
                    <label><input type="radio" name="q3" value="c"> Vectorul de distanțe minime de la nodul de start</label>
                    <label><input type="radio" name="q3" value="d"> Vectorul de muchii ale grafului</label>
                </div>
                <div class="question">
                    <h3>4. Cum sunt actualizate distanțele în algoritmul BFS?</h3>
                    <label><input type="radio" name="q4" value="a"> Prin adăugarea costului muchiei la distanța curentă</label>
                    <label><input type="radio" name="q4" value="b"> Prin scăderea costului muchiei din distanța curentă</label>
                    <label><input type="radio" name="q4" value="c"> Prin împărțirea distanței curente la costul muchiei</label>
                    <label><input type="radio" name="q4" value="d"> Prin înmulțirea distanței curente cu costul muchiei</label>
                </div>
                <div class="question">
                    <h3>5. Ce se întâmplă când un nod este deja vizitat în algoritmul BFS?</h3>
                    <label><input type="radio" name="q5" value="a"> Este adăugat din nou în coadă</label>
                    <label><input type="radio" name="q5" value="b"> Este ignorat</label>
                    <label><input type="radio" name="q5" value="c"> Este șters din vectorul de distanțe</label>
                    <label><input type="radio" name="q5" value="d"> Este actualizat cu o nouă distanță</label>
                </div>
                <div class="question">
                    <h3>6. Ce librărie este utilizată pentru a manipula vectorii în algoritmul BFS?</h3>
                    <label><input type="radio" name="q6" value="a"> #include &lt;list&gt;</label>
                    <label><input type="radio" name="q6" value="b"> #include &lt;vector&gt;</label>
                    <label><input type="radio" name="q6" value="c"> #include &lt;queue&gt;</label>
                    <label><input type="radio" name="q6" value="d"> #include &lt;stack&gt;</label>
                </div>
                <div class="question">
                    <h3>7. Cum este reprezentat graful în algoritmul BFS?</h3>
                    <label><input type="radio" name="q7" value="a"> Listă de muchii</label>
                    <label><input type="radio" name="q7" value="b"> Matrice de adiacență</label>
                    <label><input type="radio" name="q7" value="c"> Listă de adiacență</label>
                    <label><input type="radio" name="q7" value="d"> Matrice de incidență</label>
                </div>
                <div class="question">
                    <h3>8. Ce funcție este folosită pentru a adăuga un nod în coadă?</h3>
                    <label><input type="radio" name="q8" value="a"> push()</label>
                    <label><input type="radio" name="q8" value="b"> add()</label>
                    <label><input type="radio" name="q8" value="c"> insert()</label>
                    <label><input type="radio" name="q8" value="d"> enqueue()</label>
                </div>
                <div class="question">
                    <h3>9. Care este complexitatea temporală a algoritmului BFS?</h3>
                    <label><input type="radio" name="q9" value="a"> O(V + E)</label>
                    <label><input type="radio" name="q9" value="b"> O(V^2)</label>
                    <label><input type="radio" name="q9" value="c"> O(E^2)</label>
                    <label><input type="radio" name="q9" value="d"> O(VE)</label>
                </div>
                <div class="question">
                    <h3>10. Ce se întâmplă cu nodurile care urmează să fie parcurse în BFS?</h3>
                    <label><input type="radio" name="q10" value="a"> Sunt adăugate în stivă</label>
                    <label><input type="radio" name="q10" value="b"> Sunt adăugate în coadă</label>
                    <label><input type="radio" name="q10" value="c"> Sunt adăugate într-un vector de noduri parcurse</label>
                    <label><input type="radio" name="q10" value="d"> Sunt adăugate într-un arbore de parcurgere</label>
                </div>
                <div class="submit-container">
                    <button type="button" class="button" onclick="submitQuiz()">Submit</button>
                </div>
                <div id="result"></div>
                <div id="unanswered-questions" style="color: red;"></div>
            </form>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p class="footer-left">&copy; 2024 SimAlgo Learning</p>
            <p class="footer-center">Made with <span class="heart">❤</span></p>
            <p class="footer-right" id="current-time"></p>
        </div>
    </footer>

    <script>
        const correctAnswers = {
            q1: 'b',
            q2: 'b',
            q3: 'c',
            q4: 'a',
            q5: 'b',
            q6: 'b',
            q7: 'c',
            q8: 'a',
            q9: 'a',
            q10: 'b'
        };

        function submitQuiz() {
            let score = 0;
            let unanswered = 0;
            for (const [question, correctAnswer] of Object.entries(correctAnswers)) {
                const selectedOption = document.querySelector(`input[name="${question}"]:checked`);
                const options = document.querySelectorAll(`input[name="${question}"]`);

                if (!selectedOption) {
                    unanswered++;
                    continue;
                }

                if (selectedOption.value === correctAnswer) {
                    score++;
                    selectedOption.parentElement.classList.add('correct');
                } else {
                    selectedOption.parentElement.classList.add('incorrect');
                    options.forEach(option => {
                        if (option.value === correctAnswer) {
                            option.parentElement.classList.add('correct');
                        }
                    });
                }
            }

            const resultContainer = document.getElementById('result');
            resultContainer.innerHTML = `Scorul tău este: ${score} / 10`;
            const unansweredContainer = document.getElementById('unanswered-questions');
            if (unanswered > 0) {
                unansweredContainer.innerHTML = `Întrebări rămase: ${unanswered}`;
            } else {
                unansweredContainer.innerHTML = '';
            }

            resultContainer.className = '';
            if (score <= 3) {
                resultContainer.classList.add('red');
            } else if (score <= 6) {
                resultContainer.classList.add('orange');
            } else if (score <= 8) {
                resultContainer.classList.add('yellow');
            } else {
                resultContainer.classList.add('green');
            }
        }

        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('current-time').textContent = timeString;
        }
        setInterval(updateTime, 1000);
        updateTime();

        const navToggle = document.querySelector('.nav-toggle');
        const navLinks = document.querySelector('.nav-links');

        navToggle.addEventListener('click', () => {
            navLinks.classList.toggle('nav-links_visible');
        });

        document.querySelectorAll('input[type="radio"]').forEach(input => {
            input.addEventListener('change', () => {
                const name = input.name;
                document.querySelectorAll(`input[name="${name}"]`).forEach(radio => {
                    radio.parentElement.classList.remove('selected');
                });
                input.parentElement.classList.add('selected');
            });
        });
    </script>
</body>
</html>
