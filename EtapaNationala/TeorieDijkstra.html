<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimAlgo Learning - Teorie Dijkstra</title>
    <link rel="stylesheet" href="TeorieDijkstra.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="navbar">
        <div class="navbar-content">
            <div class="logo">
                <img src="logo.png" alt="SimAlgo Learning Logo" class="logo-img">
                SimAlgo Learning
            </div>
            <nav>
                <ul class="nav-links">
                    <li><a href="home.html">HOME</a></li>
                    <li><a href="Algoritmi.html">Algoritmi</a></li>
                    <li><a href="Despre.html">Despre noi</a></li>
                </ul>
              
            </nav>
            <button class="nav-toggle" aria-label="toggle navigation">
                <span class="hamburger"></span>
            </button>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="content-column">
                <h1>Dijkstra's Algorithm</h1>
                <div id="teorie" class="content-section">
                    <h2>Teorie</h2>
                    <p>Algoritmul Dijkstra este un algoritm pentru găsirea celui mai scurt drum între noduri într-un graf ponderat, ceea ce poate reprezenta, de exemplu, rețele de drumuri. Este utilizat în principal pentru a rezolva problema drumului minim dintr-un singur punct sursă la toate celelalte puncte din graf.</p>
                </div>
            </div>
            <div class="visualization-column">
                <div id="visualization">
                    <div class="controls">
                        <button onclick="resetMaze()" class="button">Reset</button>
                        <button onclick="startBFS()" class="button">Start</button>
                        <button onclick="stopBFS()" class="button">Stop</button>
                    </div>
                    <div id="maze"></div>
                </div>
            </div>
        </div>
        <div class="source-code">
            <h2>Source Code:</h2>
            <pre><code class="code-block">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using namespace std;

ifstream fin("dijkstra.in");
ofstream fout("dijkstra.out");

const int NMax = 50005;
const int oo = (1 &lt;&lt; 30);

int N, M;
int D[NMax];
bool InCoada[NMax];

vector&lt;pair&lt;int,int&gt;&gt; G[NMax];

struct compara
{
    bool operator()(int x, int y)
    {
        return D[x] &gt; D[y];
    }
};

priority_queue&lt;int, vector&lt;int&gt;, compara&gt; Coada;

void Citeste()
{
    fin &gt;&gt; N &gt;&gt; M;
    for(int i = 1; i &lt;= M; i++)
    {
        int x, y, c;
        fin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        G[x].push_back(make_pair(y,c));
    }
}

void Dijkstra(int nodStart)
{
    for(int i = 1; i &lt;= N; i++)
        D[i] = oo;

    D[nodStart] = 0;

    Coada.push(nodStart);
    InCoada[nodStart] = true;

    while(!Coada.empty())
    {
        int nodCurent = Coada.top();
        Coada.pop();

        InCoada[nodCurent] = false;
        for(size_t i = 0; i &lt; G[nodCurent].size(); i++)
        {
            int Vecin = G[nodCurent][i].first;
            int Cost = G[nodCurent][i].second;
            if(D[nodCurent] + Cost &lt; D[Vecin])
            {
                D[Vecin] = D[nodCurent] + Cost;
                if(InCoada[Vecin] == false)
                {
                    Coada.push(Vecin);
                    InCoada[Vecin] = true;
                }
            }
        }
    }
}

void Afiseaza()
{
    for(int i = 2; i &lt;= N; i++)
    {
        if(D[i] != oo)
            fout &lt;&lt; D[i] &lt;&lt; " ";
        else
            fout &lt;&lt; "0 ";
    }
}

int main()
{
    Citeste();
    Dijkstra(1);
    Afiseaza();
}
            </code></pre>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p class="footer-left">&copy; 2024 SimAlgo Learning</p>
            <p class="footer-center">Made with <span class="heart">❤</span></p>
            <p class="footer-right" id="current-time"></p>
        </div>
    </footer>

    <script>
        const numRows = 15;
        const numCols = 15;
        let grid = [];
        let startCell = null;
        let endCell = null;
        let isRunning = false;
        let stopRequested = false;

        function createGrid() {
            const gridContainer = document.getElementById('maze');
            gridContainer.innerHTML = '';
            grid = [];
            for (let row = 0; row < numRows; row++) {
                const gridRow = [];
                for (let col = 0; col < numCols; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', handleCellClick);
                    gridContainer.appendChild(cell);
                    gridRow.push(cell);
                }
                grid.push(gridRow);
            }
        }

        function handleCellClick(event) {
            const cell = event.target;
            if (isRunning) return;
            if (!startCell) {
                cell.classList.add('start');
                startCell = cell;
            } else if (!endCell) {
                cell.classList.add('end');
                endCell = cell;
            } else {
                cell.classList.toggle('obstacle');
            }
        }

        function resetMaze() {
            isRunning = false;
            stopRequested = false;
            startCell = null;
            endCell = null;
            createGrid();
        }

        async function startBFS() {
            if (!startCell || !endCell) return alert('Please select start and end cells.');

            isRunning = true;
            stopRequested = false;
            const start = [parseInt(startCell.dataset.row), parseInt(startCell.dataset.col)];
            const end = [parseInt(endCell.dataset.row), parseInt(endCell.dataset.col)];

            const directions = [
                [0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            const distance = Array.from({ length: numRows }, () => Array(numCols).fill(Infinity));
            const prev = Array.from({ length: numRows }, () => Array(numCols).fill(null));
            distance[start[0]][start[1]] = 0;

            const queue = [];
            queue.push(start);

            while (queue.length > 0 && !stopRequested) {
                const [row, col] = queue.shift();

                if (row === end[0] && col === end[1]) break;

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (
                        newRow >= 0 && newRow < numRows &&
                        newCol >= 0 && newCol < numCols &&
                        !grid[newRow][newCol].classList.contains('obstacle') &&
                        distance[newRow][newCol] === Infinity
                    ) {
                        distance[newRow][newCol] = distance[row][col] + 1;
                        prev[newRow][newCol] = [row, col];
                        queue.push([newRow, newCol]);
                        if (!(newRow === end[0] && newCol === end[1])) {
                            grid[newRow][newCol].classList.add('visited'); // Highlight visited cells
                        }
                        await new Promise(resolve => setTimeout(resolve, 50)); // Delay for visualization
                    }
                }
            }

            if (!stopRequested) {
                let current = end;
                while (current) {
                    const [row, col] = current;
                    if (!(row === start[0] && col === start[1])) {
                        grid[row][col].classList.add('path'); // Highlight shortest path
                    }
                    current = prev[row][col];
                    await new Promise(resolve => setTimeout(resolve, 50)); // Delay for visualization
                }
            }
        }

        function stopBFS() {
            stopRequested = true;
            isRunning = false;
        }

        createGrid();
        function updateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('current-time').textContent = timeString;
        }
        setInterval(updateTime, 1000);
        updateTime();
    </script>
</body>
</html>